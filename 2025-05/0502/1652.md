# 📝 알고리즘 문제 풀이 - 2025-03-05

## 문제 📖

- **문제 링크:** [Boj - 1652](https://www.acmicpc.net/problem/1652)

- **문제 유형:** 문자열

- **난이도:** 실5

- **풀이 시간:** ⏳ 30분

## ✍ 접근 방식

- 문제 요구사항

  - 가로줄에서 연속된 '.'이 2칸 이상인 곳마다 누울 수 있는 자리 1개로 센다
  - 세로줄에서도 마찬가지
  - 최종적으로 가로로 누울 수 있는 자리 수, 세로로 누울 수 있는 자리 수 출력

- 알고리즘
- 내가 푼 방법

  - 가로, 세로 각각 이중 for문으로 !
  - 이거말고 다른 방법이 있나?

- 다른 알고리즘

  - 1. 문자열로 접근 (정규표현식 or split)
  - 이방법 장점
    - 인덱스 관리나 count 변수 안 써도 돼
    - 문자열 조작 (split, filter)로 짧고 직관적
    - 코드 간결
    - 2중 for문 없고 → 단일 for문 + 문자열 처리

  ```js
  const fs = require('fs');
  const input = fs.readFileSync('/dev/stdin').toString().trim().split('\n');
  const N = parseInt(input[0]);
  const grid = input.slice(1);

  let rowCount = 0;
  let colCount = 0;

  // 가로 검사
  for (let row of grid) {
    const parts = row.split('X');
    rowCount += parts.filter((part) => part.length >= 2).length;
  }

  // 세로 검사 → 각 열을 문자열로 만들어 처리
  for (let j = 0; j < N; j++) {
    let colStr = '';
    for (let i = 0; i < N; i++) {
      colStr += grid[i][j];
    }
    const parts = colStr.split('X');
    colCount += parts.filter((part) => part.length >= 2).length;
  }

  console.log(rowCount colCount);
  ```

  - 2. 배열 회전(transpose) → 가로 검사 2번만
  - 이방법 장점
    - 가로 검사 함수 1개만 구현 → 가로/세로에 공통으로 사용
    - 논리적으로도 깔끔
    - 구조화된 함수형 스타일

  ```js
  function transpose(matrix) {
    return matrix[0].map((_, colIndex) => matrix.map((row) => row[colIndex]).join(''));
  }

  const fs = require('fs');
  const input = fs.readFileSync('/dev/stdin').toString().trim().split('\n');

  const N = parseInt(input[0]);
  const grid = input.slice(1);

  function countRow(lineArr) {
    return lineArr.reduce((acc, line) => {
      return acc + line.split('X').filter((part) => part.length >= 2).length;
    }, 0);
  }

  const rowCount = countRow(grid);
  const colCount = countRow(transpose(grid));

  console.log(rowCount colCount);
  ```

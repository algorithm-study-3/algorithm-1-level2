# 📝 알고리즘 문제 풀이 - 2025-05-03

## 문제 📖

- **문제 링크:** [Boj - 5525](https://www.acmicpc.net/problem/5525)

- **문제 유형:** 문자열

- **난이도:** 실1

- **풀이 시간:** ⏳ 30분

## ✍ 접근 방식

- 조건

  - Pn은 N+1개의 I와 N개의 O가 교대로 나오는 문자열

- 입력

  - I와 O로만 이루어진 문자열 S
  - 정수 N

- 출력

  - S안에 PN이 몇 군데 포함되어 있는지 구한다

- 풀이1 (오답)

  ```js
  const count = S.match(new RegExp(PN, 'g'))?.length || 0;
  ```

  - 오답인 이유 : RegExp + match()로는 겹치는 패턴을 카운트 못함.

- 풀이2 (50점)

  ```js
  let count = 0;
  let i = 0;

  while (i < M) {
    if (S.slice(i, i + PN.length) === PN) {
      count++;
      i += 2;
    } else {
      i++;
    }
  }
  ```

  - 직접 문자열 탐색 + 포인터 이동 방식으로 풀음
  - 패턴이 완전히 일치하는지 확인 → 발견되면 2칸 이동
  - 패턴 발견 시 i += 2로 이동하면서 겹치는 패턴을 건너뛰어 일부 경우를 놓쳤다 (i++로 바꿨으면에도 여전했음.)
  - 겹치는 패턴을 위해선 OI 반복 개수를 세면서 탐색하는 방식으로 고쳐야 함

- 풀이3 (100점)
  ```js
  while (i < M - 1) {
    if (S[i] === 'I' && S[i + 1] === 'O' && S[i + 2] === 'I') {
      patternCount++;
      i += 2;
      if (patternCount === N) {
        count++;
        patternCount--;
      }
    } else {
      patternCount = 0;
      i++;
    }
  }
  ```
  - 방법
    - IOI 패턴이 연속적으로 나올 때 OI 반복 횟수를 카운트하여 겹치는 패턴도 모두 세도록 했다
  - 장점
    - 매번 새로운 IOI를 slice() 같은 방식으로 자를 필요 없음
    - O나 I가 연속적으로 나와도 문제 없음

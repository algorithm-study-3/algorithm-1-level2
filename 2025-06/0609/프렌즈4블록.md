# 📝 알고리즘 문제 풀이 - 2025-06-09

## 문제 📖

- **문제 링크:** [prog - 프렌즈 4블록](https://school.programmers.co.kr/learn/courses/30/lessons/17679)

- **문제 유형:** 문자열

- **난이도:**

- **풀이 시간:** ⏳ 40분

## ✍ 접근 방식

- (어떤 방법으로 접근했는지 설명)
- (다른 풀이를 참고했다면 어떤걸 배웠는지)

- 2x2 블록 탐색 및 체크
  check 함수는 전체 보드를 순회하며, 각 칸을 기준으로 오른쪽, 아래, 대각선 아래가 모두 같은 블록(문자)이면 해당 위치들을 changed 배열에 표시. 이미 표시된 칸은 중복 카운트하지 않도록 처리.

- 블록 제거
  changed 배열에 표시된 위치의 블록을 '\*'로 바꿔 제거.

- 블록 내리기(재정렬)
  '\*'로 바뀐 칸에 대해 위에서 블록을 찾아 내려보냄. 위에서부터 블록을 찾아 내려보내는 방식으로 중력 효과를 구현.

- 반복
  solution 함수는 check를 반복 호출하여 더 이상 지울 블록이 없을 때까지 위 과정을 반복하고, 총 제거된 블록 수를 반환.

### 최적의 코드

```ts
function solution(m, n, board) {
  let grid = board.map((row) => row.split(''));
  let total = 0;

  while (true) {
    // 1. 제거할 블록 좌표 수집 (Set 사용)
    const toRemove = new Set();

    for (let i = 0; i < m - 1; i++) {
      for (let j = 0; j < n - 1; j++) {
        const current = grid[i][j];
        if (current === '*') continue;
        if (
          grid[i + 1][j] === current &&
          grid[i][j + 1] === current &&
          grid[i + 1][j + 1] === current
        ) {
          toRemove
            .add(`${i},${j}`)
            .add(`${i + 1},${j}`)
            .add(`${i},${j + 1}`)
            .add(`${i + 1},${j + 1}`);
        }
      }
    }

    // 2. 더 이상 제거할 블록 없으면 종료
    if (toRemove.size === 0) break;
    total += toRemove.size;

    // 3. 블록 제거 (*로 표시)
    toRemove.forEach((pos) => {
      const [x, y] = pos.split(',').map(Number);
      grid[x][y] = '*';
    });

    // 4. 열 단위로 블록 재정렬 (효율적 처리)
    for (let j = 0; j < n; j++) {
      const column = [];
      for (let i = m - 1; i >= 0; i--) {
        if (grid[i][j] !== '*') column.push(grid[i][j]);
      }
      for (let i = m - 1; i >= 0; i--) {
        grid[i][j] = column[m - 1 - i] || '*';
      }
    }
  }

  return total;
}
```

- 나의 경우 checked 라는 2차원 배열로 삭제될 블록들을 bool값으로 관리했다면 위의 예시 코드에서는 Set으로 x,y position을 관리했다. 이게 더 효과적인것 같다.
  사유 : 안멍청해보임 ㅋ
